"""
Strategy Manager Service

Responsibilities:
- Plugin registry and discovery
- Lifecycle management (load/unload/reload)
- Strategy versioning and rollback
- Hot-reload without restart
- Strategy performance monitoring
"""

import asyncio
import json
import os
from datetime import datetime
from typing import Dict, List, Optional, Any
from dataclasses import asdict
import uuid

import nats
from nats.aio.client import Client as NATS
from nats.js import JetStreamContext
from fastapi import FastAPI, HTTPException, BackgroundTasks
from fastapi.responses import JSONResponse
import structlog
from prometheus_client import Counter, Histogram, Gauge, generate_latest
from fastapi.responses import Response

from .plugin_manager import PluginManager
from .strategy_interface import StrategyConfig, MarketSignal, StrategyDecision, DecisionType

# Configure structured logging
structlog.configure(
    processors=[
        structlog.stdlib.filter_by_level,
        structlog.stdlib.add_logger_name,
        structlog.stdlib.add_log_level,
        structlog.stdlib.PositionalArgumentsFormatter(),
        structlog.processors.JSONRenderer()
    ],
    context_class=dict,
    logger_factory=structlog.stdlib.LoggerFactory(),
    wrapper_class=structlog.stdlib.BoundLogger,
    cache_logger_on_first_use=True,
)

logger = structlog.get_logger()

# Prometheus metrics
strategies_loaded = Gauge('strategy_manager_loaded_total', 'Number of loaded strategies')
strategies_active = Gauge('strategy_manager_active_total', 'Number of active strategies')
strategy_decisions = Counter('strategy_manager_decisions_total', 'Decisions generated by strategies', ['strategy', 'decision'])
strategy_errors = Counter('strategy_manager_errors_total', 'Strategy errors', ['strategy', 'error_type'])
strategy_reload_count = Counter('strategy_manager_reloads_total', 'Strategy reload count', ['strategy'])
signal_processing_time = Histogram('strategy_manager_signal_processing_seconds', 'Time to process signals', ['strategy'])

class StrategyManagerService:
    def __init__(self):
        self.nats_client: Optional[NATS] = None
        self.js: Optional[JetStreamContext] = None
        self.plugin_manager = PluginManager(
            plugins_directory=os.getenv("STRATEGIES_DIR", "plugins"),
            registry_file=os.getenv("REGISTRY_FILE", "strategy_registry.json")
        )

    async def connect_nats(self):
        """Connect to NATS JetStream."""
        nats_url = os.getenv("NATS_URL", "nats://localhost:4222")
        try:
            self.nats_client = await nats.connect(nats_url)
            self.js = self.nats_client.jetstream()
            logger.info("Connected to NATS", url=nats_url)

            # Subscribe to signals for strategy processing
            await self.js.subscribe(
                "signals.normalized",
                cb=self._handle_signal,
                durable="strategy-manager-signals",
                queue="strategy-manager"
            )

            # Subscribe to fills for strategy position updates
            await self.js.subscribe(
                "executions.fill",
                cb=self._handle_fill,
                durable="strategy-manager-fills",
                queue="strategy-manager"
            )

        except Exception as e:
            logger.error("Failed to connect to NATS", error=str(e))
            raise

    async def _handle_signal(self, msg):
        """Process incoming market signals with all active strategies."""
        try:
            data = json.loads(msg.data.decode())

            signal = MarketSignal(
                symbol=data["symbol"],
                price=data["price"],
                volume=data.get("volume", 0),
                timestamp=datetime.fromisoformat(data["timestamp"]),
                bid=data.get("bid"),
                ask=data.get("ask"),
                correlation_id=data.get("correlation_id", ""),
                metadata=data.get("metadata")
            )

            # Process signal with all active strategies
            await self._process_signal_with_strategies(signal)

            await msg.ack()

        except Exception as e:
            logger.error("Error processing signal", error=str(e))
            await msg.nak()

    async def _process_signal_with_strategies(self, signal: MarketSignal):
        """Process signal with all active strategies."""
        active_plugins = {
            name: instance for name, instance in self.plugin_manager.plugins.items()
            if instance.status.value == "active"
        }

        if not active_plugins:
            return

        # Process signal with each active strategy
        tasks = []
        for plugin_name, instance in active_plugins.items():
            task = self._process_signal_with_strategy(plugin_name, instance.strategy, signal)
            tasks.append(task)

        # Wait for all strategies to process signal
        await asyncio.gather(*tasks, return_exceptions=True)

    async def _process_signal_with_strategy(self, plugin_name: str, strategy, signal: MarketSignal):
        """Process signal with a single strategy."""
        try:
            with signal_processing_time.labels(strategy=plugin_name).time():
                decision = await strategy.on_signal(signal)

                if decision:
                    # Publish decision
                    await self._publish_strategy_decision(plugin_name, decision, signal.correlation_id)

                    strategy_decisions.labels(
                        strategy=plugin_name,
                        decision=decision.decision.value
                    ).inc()

        except Exception as e:
            logger.error("Strategy signal processing failed",
                        strategy=plugin_name,
                        error=str(e))
            strategy_errors.labels(strategy=plugin_name, error_type="signal_processing").inc()

            # Update plugin error count
            instance = self.plugin_manager.get_plugin_instance(plugin_name)
            if instance:
                instance.error_count += 1
                instance.last_error = str(e)

    async def _publish_strategy_decision(self, strategy_name: str, decision: StrategyDecision, correlation_id: str):
        """Publish strategy decision to NATS."""
        try:
            decision_data = {
                "agent_id": f"strategy-{strategy_name}",
                "symbol": decision.symbol,
                "action": decision.decision.value,
                "quantity": decision.quantity,
                "confidence": decision.confidence,
                "price": decision.price_limit,
                "reasoning": decision.reasoning,
                "timestamp": datetime.utcnow().isoformat(),
                "correlation_id": correlation_id,
                "metadata": decision.metadata or {}
            }

            if self.js:
                await self.js.publish(
                    "decisions.order_intent",
                    json.dumps(decision_data).encode()
                )

            logger.debug("Strategy decision published",
                        strategy=strategy_name,
                        symbol=decision.symbol,
                        action=decision.decision.value,
                        confidence=decision.confidence)

        except Exception as e:
            logger.error("Failed to publish strategy decision",
                        strategy=strategy_name,
                        error=str(e))

    async def _handle_fill(self, msg):
        """Handle order fills and update strategy positions."""
        try:
            data = json.loads(msg.data.decode())

            # Extract strategy name from agent_id if possible
            agent_id = data.get("agent_id", "")
            if agent_id.startswith("strategy-"):
                strategy_name = agent_id.replace("strategy-", "")

                instance = self.plugin_manager.get_plugin_instance(strategy_name)
                if instance:
                    await instance.strategy.on_fill(
                        symbol=data["symbol"],
                        quantity=data["quantity"],
                        price=data["price"],
                        commission=data.get("commission", 0.0)
                    )

            await msg.ack()

        except Exception as e:
            logger.error("Error processing fill", error=str(e))
            await msg.nak()

    async def update_metrics(self):
        """Update Prometheus metrics."""
        try:
            plugins = self.plugin_manager.list_plugins()

            loaded_count = sum(1 for p in plugins.values() if p["loaded"])
            active_count = sum(1 for p in plugins.values() if p.get("status") == "active")

            strategies_loaded.set(loaded_count)
            strategies_active.set(active_count)

        except Exception as e:
            logger.error("Failed to update metrics", error=str(e))

# FastAPI app
app = FastAPI(title="Strategy Manager Service", version="0.1.0")
strategy_service = StrategyManagerService()

@app.on_event("startup")
async def startup():
    """Initialize service on startup."""
    await strategy_service.plugin_manager.initialize()
    await strategy_service.connect_nats()

    # Start metrics update task
    asyncio.create_task(periodic_metrics_update())

@app.on_event("shutdown")
async def shutdown():
    """Clean shutdown."""
    await strategy_service.plugin_manager.shutdown()
    if strategy_service.nats_client:
        await strategy_service.nats_client.close()

async def periodic_metrics_update():
    """Periodically update metrics."""
    while True:
        try:
            await strategy_service.update_metrics()
            await asyncio.sleep(30)  # Update every 30 seconds
        except Exception as e:
            logger.error("Metrics update failed", error=str(e))

@app.get("/healthz")
async def health_check():
    """Health check endpoint."""
    plugins = strategy_service.plugin_manager.list_plugins()
    return {
        "status": "healthy",
        "service": "strategy-manager",
        "timestamp": datetime.utcnow().isoformat(),
        "nats_connected": strategy_service.nats_client is not None,
        "total_plugins": len(plugins),
        "loaded_plugins": sum(1 for p in plugins.values() if p["loaded"]),
        "active_plugins": sum(1 for p in plugins.values() if p.get("status") == "active")
    }

@app.get("/metrics")
async def metrics():
    """Prometheus metrics endpoint."""
    return Response(generate_latest(), media_type="text/plain")

# Plugin Management Endpoints

@app.get("/strategies")
async def list_strategies():
    """List all strategies with their status."""
    plugins = strategy_service.plugin_manager.list_plugins()
    return {"strategies": plugins}

@app.post("/strategies/{strategy_name}/load")
async def load_strategy(
    strategy_name: str,
    config: Dict[str, Any] = None
):
    """Load a strategy plugin."""
    try:
        if not config:
            config = {
                "name": strategy_name,
                "version": "1.0.0",
                "enabled": True,
                "parameters": {},
                "risk_limits": {}
            }

        strategy_config = StrategyConfig(**config)
        success = await strategy_service.plugin_manager.load_plugin(strategy_name, strategy_config)

        if success:
            return {"status": "loaded", "strategy": strategy_name}
        else:
            raise HTTPException(status_code=400, detail="Failed to load strategy")

    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))

@app.post("/strategies/{strategy_name}/unload")
async def unload_strategy(strategy_name: str):
    """Unload a strategy plugin."""
    try:
        success = await strategy_service.plugin_manager.unload_plugin(strategy_name)
        if success:
            return {"status": "unloaded", "strategy": strategy_name}
        else:
            raise HTTPException(status_code=400, detail="Failed to unload strategy")
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))

@app.post("/strategies/{strategy_name}/reload")
async def reload_strategy(strategy_name: str):
    """Reload a strategy plugin (hot-reload)."""
    try:
        success = await strategy_service.plugin_manager.reload_plugin(strategy_name)
        strategy_reload_count.labels(strategy=strategy_name).inc()

        if success:
            return {"status": "reloaded", "strategy": strategy_name}
        else:
            raise HTTPException(status_code=400, detail="Failed to reload strategy")
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))

@app.post("/strategies/{strategy_name}/start")
async def start_strategy(strategy_name: str):
    """Start a loaded strategy."""
    try:
        success = await strategy_service.plugin_manager.start_plugin(strategy_name)
        if success:
            return {"status": "started", "strategy": strategy_name}
        else:
            raise HTTPException(status_code=400, detail="Strategy not loaded or already running")
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))

@app.post("/strategies/{strategy_name}/stop")
async def stop_strategy(strategy_name: str):
    """Stop a running strategy."""
    try:
        success = await strategy_service.plugin_manager.stop_plugin(strategy_name)
        if success:
            return {"status": "stopped", "strategy": strategy_name}
        else:
            raise HTTPException(status_code=400, detail="Strategy not loaded or not running")
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))

@app.post("/strategies/{strategy_name}/pause")
async def pause_strategy(strategy_name: str):
    """Pause a running strategy."""
    try:
        success = await strategy_service.plugin_manager.pause_plugin(strategy_name)
        if success:
            return {"status": "paused", "strategy": strategy_name}
        else:
            raise HTTPException(status_code=400, detail="Strategy not loaded or not running")
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))

@app.post("/strategies/{strategy_name}/resume")
async def resume_strategy(strategy_name: str):
    """Resume a paused strategy."""
    try:
        success = await strategy_service.plugin_manager.resume_plugin(strategy_name)
        if success:
            return {"status": "resumed", "strategy": strategy_name}
        else:
            raise HTTPException(status_code=400, detail="Strategy not loaded or not paused")
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))

@app.put("/strategies/{strategy_name}/config")
async def update_strategy_config(strategy_name: str, config: Dict[str, Any]):
    """Update strategy configuration."""
    try:
        strategy_config = StrategyConfig(**config)
        success = await strategy_service.plugin_manager.update_plugin_config(strategy_name, strategy_config)

        if success:
            return {"status": "config_updated", "strategy": strategy_name}
        else:
            raise HTTPException(status_code=400, detail="Strategy not loaded")
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))

@app.get("/strategies/{strategy_name}/health")
async def get_strategy_health(strategy_name: str):
    """Get strategy health status."""
    try:
        health = await strategy_service.plugin_manager.get_plugin_health(strategy_name)
        if health is not None:
            return health
        else:
            raise HTTPException(status_code=404, detail="Strategy not found or not loaded")
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))

@app.get("/strategies/{strategy_name}/positions")
async def get_strategy_positions(strategy_name: str):
    """Get strategy positions."""
    try:
        instance = strategy_service.plugin_manager.get_plugin_instance(strategy_name)
        if not instance:
            raise HTTPException(status_code=404, detail="Strategy not found or not loaded")

        positions = await instance.strategy.get_positions()
        return {"positions": [asdict(pos) for pos in positions.values()]}
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))

@app.get("/strategies/{strategy_name}/performance")
async def get_strategy_performance(strategy_name: str):
    """Get strategy performance metrics."""
    try:
        instance = strategy_service.plugin_manager.get_plugin_instance(strategy_name)
        if not instance:
            raise HTTPException(status_code=404, detail="Strategy not found or not loaded")

        performance = await instance.strategy.get_performance()
        return asdict(performance)
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8007)
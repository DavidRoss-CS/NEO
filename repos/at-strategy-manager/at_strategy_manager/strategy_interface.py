"""
Standard interface definition for all trading strategies.

All strategy plugins must implement the IStrategy interface to be compatible
with the strategy manager and execution system.
"""

from abc import ABC, abstractmethod
from typing import Dict, List, Optional, Any, Tuple
from dataclasses import dataclass
from datetime import datetime
from enum import Enum

class DecisionType(Enum):
    BUY = "BUY"
    SELL = "SELL"
    HOLD = "HOLD"

class StrategyStatus(Enum):
    INACTIVE = "inactive"
    ACTIVE = "active"
    PAUSED = "paused"
    ERROR = "error"

@dataclass
class MarketSignal:
    """Input signal to strategy."""
    symbol: str
    price: float
    volume: int
    timestamp: datetime
    bid: Optional[float] = None
    ask: Optional[float] = None
    correlation_id: str = ""
    metadata: Optional[Dict[str, Any]] = None

@dataclass
class StrategyDecision:
    """Output decision from strategy."""
    symbol: str
    decision: DecisionType
    quantity: float
    confidence: float  # 0.0 to 1.0
    price_limit: Optional[float] = None
    reasoning: str = ""
    metadata: Optional[Dict[str, Any]] = None

@dataclass
class StrategyPosition:
    """Current position held by strategy."""
    symbol: str
    quantity: float
    average_price: float
    unrealized_pnl: float
    realized_pnl: float

@dataclass
class StrategyPerformance:
    """Performance metrics for strategy."""
    total_return: float
    sharpe_ratio: float
    max_drawdown: float
    win_rate: float
    total_trades: int
    active_positions: int
    portfolio_value: float

@dataclass
class StrategyConfig:
    """Configuration parameters for strategy."""
    name: str
    version: str
    enabled: bool
    parameters: Dict[str, Any]
    risk_limits: Dict[str, float]

class IStrategy(ABC):
    """
    Abstract base class that all trading strategies must implement.

    This interface ensures compatibility with the strategy manager and
    provides a consistent API for strategy lifecycle management.
    """

    def __init__(self, config: StrategyConfig):
        """
        Initialize strategy with configuration.

        Args:
            config: Strategy configuration parameters
        """
        self.config = config
        self.status = StrategyStatus.INACTIVE
        self.positions: Dict[str, StrategyPosition] = {}
        self.performance = StrategyPerformance(
            total_return=0.0,
            sharpe_ratio=0.0,
            max_drawdown=0.0,
            win_rate=0.0,
            total_trades=0,
            active_positions=0,
            portfolio_value=0.0
        )

    @abstractmethod
    async def initialize(self) -> bool:
        """
        Initialize strategy resources and state.

        Called when strategy is first loaded or reloaded.
        Should set up any required state, models, or connections.

        Returns:
            True if initialization successful, False otherwise
        """
        pass

    @abstractmethod
    async def on_signal(self, signal: MarketSignal) -> Optional[StrategyDecision]:
        """
        Process market signal and generate trading decision.

        Args:
            signal: Market signal containing price, volume, and other data

        Returns:
            Trading decision or None if no action should be taken
        """
        pass

    @abstractmethod
    async def on_fill(self, symbol: str, quantity: float, price: float, commission: float):
        """
        Handle order fill notification.

        Called when an order generated by this strategy is filled.
        Should update position tracking and performance metrics.

        Args:
            symbol: Symbol that was traded
            quantity: Quantity filled (positive for buy, negative for sell)
            price: Fill price
            commission: Commission paid
        """
        pass

    @abstractmethod
    async def get_health_status(self) -> Dict[str, Any]:
        """
        Return strategy health and diagnostic information.

        Returns:
            Dictionary containing health metrics, warnings, errors, etc.
        """
        pass

    @abstractmethod
    async def cleanup(self):
        """
        Clean up strategy resources.

        Called when strategy is unloaded or system is shutting down.
        Should close connections, save state, and free resources.
        """
        pass

    # Optional methods with default implementations

    async def on_start(self):
        """Called when strategy is activated."""
        self.status = StrategyStatus.ACTIVE

    async def on_stop(self):
        """Called when strategy is deactivated."""
        self.status = StrategyStatus.INACTIVE

    async def on_pause(self):
        """Called when strategy is paused."""
        self.status = StrategyStatus.PAUSED

    async def on_resume(self):
        """Called when strategy is resumed from pause."""
        self.status = StrategyStatus.ACTIVE

    async def on_config_update(self, new_config: StrategyConfig):
        """
        Handle configuration updates.

        Args:
            new_config: Updated configuration
        """
        self.config = new_config

    async def get_positions(self) -> Dict[str, StrategyPosition]:
        """Get current positions held by strategy."""
        return self.positions.copy()

    async def get_performance(self) -> StrategyPerformance:
        """Get current performance metrics."""
        return self.performance

    def update_position(self, symbol: str, quantity_change: float, price: float):
        """
        Update position tracking (helper method).

        Args:
            symbol: Symbol being traded
            quantity_change: Change in quantity (+ for buy, - for sell)
            price: Trade price
        """
        if symbol not in self.positions:
            self.positions[symbol] = StrategyPosition(
                symbol=symbol,
                quantity=0,
                average_price=0,
                unrealized_pnl=0,
                realized_pnl=0
            )

        position = self.positions[symbol]

        if quantity_change > 0:  # Buy
            # Update average price
            if position.quantity >= 0:
                total_cost = (position.quantity * position.average_price) + (quantity_change * price)
                position.quantity += quantity_change
                position.average_price = total_cost / position.quantity if position.quantity > 0 else 0
            else:
                # Covering short position
                covered = min(abs(position.quantity), quantity_change)
                position.realized_pnl += (position.average_price - price) * covered
                position.quantity += quantity_change

                if position.quantity > 0:
                    position.average_price = price

        else:  # Sell
            quantity_change = abs(quantity_change)
            if position.quantity > 0:
                # Selling long position
                sold = min(position.quantity, quantity_change)
                position.realized_pnl += (price - position.average_price) * sold
                position.quantity -= quantity_change

                if position.quantity < 0:
                    position.average_price = price
            else:
                # Adding to short position
                total_cost = (abs(position.quantity) * position.average_price) + (quantity_change * price)
                position.quantity -= quantity_change
                position.average_price = total_cost / abs(position.quantity) if position.quantity < 0 else 0

        # Remove position if closed
        if position.quantity == 0:
            del self.positions[symbol]

    def calculate_unrealized_pnl(self, current_prices: Dict[str, float]):
        """
        Calculate unrealized P&L for all positions.

        Args:
            current_prices: Dictionary of symbol -> current price
        """
        for symbol, position in self.positions.items():
            if symbol in current_prices:
                current_price = current_prices[symbol]
                if position.quantity > 0:
                    position.unrealized_pnl = (current_price - position.average_price) * position.quantity
                else:
                    position.unrealized_pnl = (position.average_price - current_price) * abs(position.quantity)